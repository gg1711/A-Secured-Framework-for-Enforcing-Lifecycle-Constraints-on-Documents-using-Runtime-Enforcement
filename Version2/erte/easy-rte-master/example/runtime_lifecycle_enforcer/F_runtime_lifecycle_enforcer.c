
//This file should be called F_runtime_lifecycle_enforcer.c
//This is autogenerated code. Edit by hand at your peril!
#include "F_runtime_lifecycle_enforcer.h"

void runtime_lifecycle_enforcer_init_all_vars(enforcervars_runtime_lifecycle_enforcer_t* me, inputs_runtime_lifecycle_enforcer_t* inputs, outputs_runtime_lifecycle_enforcer_t* outputs) {
	//set any input vars with default values
	
	//set any output vars with default values
	

	
	me->_policy_p1_state = POLICY_STATE_runtime_lifecycle_enforcer_p1_s0;
	//input policy internal vars
	
	me->A_G1_p1 = 0;
	
	me->B_G1_p1 = 0;
	
	me->C_G1_p1 = 0;
	
	
	me->_policy_p2_state = POLICY_STATE_runtime_lifecycle_enforcer_p2_s0;
	//input policy internal vars
	
	me->E_G2_p2 = 0;
	
	me->D_G2_p2 = 0;
	
	
	me->_policy_p3_state = POLICY_STATE_runtime_lifecycle_enforcer_p3_s0;
	//input policy internal vars
	
	me->B_G1_p3 = 0;
	
	me->D_G2_p3 = 0;
	
	
}

void runtime_lifecycle_enforcer_run_via_enforcer(enforcervars_runtime_lifecycle_enforcer_t* me, inputs_runtime_lifecycle_enforcer_t* inputs, outputs_runtime_lifecycle_enforcer_t* outputs) {
	//run the policies in reverse order for the inputs (last policies have highest priority)
	
	 runtime_lifecycle_enforcer_run_input_enforcer_p3(me, inputs);
	 runtime_lifecycle_enforcer_run_input_enforcer_p2(me, inputs);
	 runtime_lifecycle_enforcer_run_input_enforcer_p1(me, inputs);
	

	runtime_lifecycle_enforcer_run(inputs, outputs);

	//run policies in specified order for outputs
	runtime_lifecycle_enforcer_run_output_enforcer_p1(me, inputs,outputs);
	runtime_lifecycle_enforcer_run_output_enforcer_p2(me, inputs,outputs);
	runtime_lifecycle_enforcer_run_output_enforcer_p3(me, inputs,outputs);
	
}


//input policies

//INPUT POLICY p1 BEGIN
//This will run the input enforcer for runtime_lifecycle_enforcer's policy p1
void runtime_lifecycle_enforcer_run_input_enforcer_p1(enforcervars_runtime_lifecycle_enforcer_t* me, inputs_runtime_lifecycle_enforcer_t* inputs) {
	switch(me->_policy_p1_state) {
		case POLICY_STATE_runtime_lifecycle_enforcer_p1_s0:
			
			if(inputs->W_A_G1 && (me->B_G1_p1 == 0 || me->C_G1_p1 == 0)) {
				//transition s0 -> violation on W_A_G1 and B_G1_p1 = 0 or C_G1_p1 = 0
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				inputs->W_A_G1 = 0;
				
			} 
			
			break;

		case POLICY_STATE_runtime_lifecycle_enforcer_p1_s1:
			
			if(inputs->W_B_G1 || inputs->W_C_G1) {
				//transition s1 -> violation on W_B_G1 or W_C_G1
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				inputs->W_B_G1 = 0;
				inputs->W_C_G1 = 0;
				
			} 
			
			break;

		
	}
}

//INPUT POLICY p1 END

//INPUT POLICY p2 BEGIN
//This will run the input enforcer for runtime_lifecycle_enforcer's policy p2
void runtime_lifecycle_enforcer_run_input_enforcer_p2(enforcervars_runtime_lifecycle_enforcer_t* me, inputs_runtime_lifecycle_enforcer_t* inputs) {
	switch(me->_policy_p2_state) {
		case POLICY_STATE_runtime_lifecycle_enforcer_p2_s0:
			
			if(inputs->W_E_G2 && me->D_G2_p2 == 0) {
				//transition s0 -> violation on W_E_G2 and D_G2_p2 = 0
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				inputs->W_E_G2 = 0;
				
			} 
			
			break;

		case POLICY_STATE_runtime_lifecycle_enforcer_p2_s1:
			
			if(inputs->W_D_G2 == 1) {
				//transition s1 -> violation on W_D_G2 = 1
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				inputs->W_D_G2 = 0;
				
			} 
			
			break;

		
	}
}

//INPUT POLICY p2 END

//INPUT POLICY p3 BEGIN
//This will run the input enforcer for runtime_lifecycle_enforcer's policy p3
void runtime_lifecycle_enforcer_run_input_enforcer_p3(enforcervars_runtime_lifecycle_enforcer_t* me, inputs_runtime_lifecycle_enforcer_t* inputs) {
	switch(me->_policy_p3_state) {
		case POLICY_STATE_runtime_lifecycle_enforcer_p3_s0:
			
			if(inputs->W_B_G1 && me->D_G2_p3 == 0) {
				//transition s0 -> violation on W_B_G1 and D_G2_p3 = 0
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				inputs->W_B_G1 = 0;
				
			} 
			
			break;

		case POLICY_STATE_runtime_lifecycle_enforcer_p3_s1:
			
			if(inputs->W_D_G2 == 1) {
				//transition s1 -> violation on W_D_G2 = 1
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				inputs->W_D_G2 = 0;
				
			} 
			
			break;

		
	}
}

//INPUT POLICY p3 END



//output policies

//OUTPUT POLICY p1 BEGIN
//This will run the input enforcer for runtime_lifecycle_enforcer's policy p1
void runtime_lifecycle_enforcer_run_output_enforcer_p1(enforcervars_runtime_lifecycle_enforcer_t* me, inputs_runtime_lifecycle_enforcer_t* inputs, outputs_runtime_lifecycle_enforcer_t* outputs) {
	//advance timers
	
	
	//run enforcer
	switch(me->_policy_p1_state) {
		case POLICY_STATE_runtime_lifecycle_enforcer_p1_s0:
			
			if(inputs->W_A_G1 && (me->B_G1_p1 == 0 || me->C_G1_p1 == 0)) {
				//transition s0 -> violation on ( W_A_G1 and ( B_G1_p1 = 0 or C_G1_p1 = 0 ) )
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 

			break;

		case POLICY_STATE_runtime_lifecycle_enforcer_p1_s1:
			
			if(inputs->W_B_G1 || inputs->W_C_G1) {
				//transition s1 -> violation on ( W_B_G1 or W_C_G1 )
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 

			break;

		
	}

	//select transition to advance state
	switch(me->_policy_p1_state) {
		case POLICY_STATE_runtime_lifecycle_enforcer_p1_s0:
			
			if((inputs->W_A_G1 && me->B_G1_p1 == 1) && me->C_G1_p1 == 1) {
				//transition s0 -> s1 on ( W_A_G1 and B_G1_p1 = 1 and C_G1_p1 = 1 )
				me->_policy_p1_state = POLICY_STATE_runtime_lifecycle_enforcer_p1_s1;
				//set expressions
				
				me->A_G1_p1 = 1;
				break;
			} 
			if(inputs->W_B_G1) {
				//transition s0 -> s0 on ( W_B_G1 )
				me->_policy_p1_state = POLICY_STATE_runtime_lifecycle_enforcer_p1_s0;
				//set expressions
				
				me->B_G1_p1 = 1;
				break;
			} 
			if(inputs->W_C_G1) {
				//transition s0 -> s0 on ( W_C_G1 )
				me->_policy_p1_state = POLICY_STATE_runtime_lifecycle_enforcer_p1_s0;
				//set expressions
				
				me->C_G1_p1 = 1;
				break;
			} 
			if(inputs->W_A_G1 && (me->B_G1_p1 == 0 || me->C_G1_p1 == 0)) {
				//transition s0 -> violation on ( W_A_G1 and ( B_G1_p1 = 0 or C_G1_p1 = 0 ) )
				me->_policy_p1_state = POLICY_STATE_runtime_lifecycle_enforcer_p1_violation;
				//set expressions
				
				break;
			} 
			
			//ensure a transition was taken in this state
			assert(false && "runtime_lifecycle_enforcer_p1_s0 must take a transition"); //if we are still here, then no transition was taken and we are no longer satisfying liveness

			break;

		case POLICY_STATE_runtime_lifecycle_enforcer_p1_s1:
			
			if(inputs->W_A_G1) {
				//transition s1 -> s1 on ( W_A_G1 )
				me->_policy_p1_state = POLICY_STATE_runtime_lifecycle_enforcer_p1_s1;
				//set expressions
				
				break;
			} 
			if(inputs->W_B_G1 || inputs->W_C_G1) {
				//transition s1 -> violation on ( W_B_G1 or W_C_G1 )
				me->_policy_p1_state = POLICY_STATE_runtime_lifecycle_enforcer_p1_violation;
				//set expressions
				
				break;
			} 
			
			//ensure a transition was taken in this state
			assert(false && "runtime_lifecycle_enforcer_p1_s1 must take a transition"); //if we are still here, then no transition was taken and we are no longer satisfying liveness

			break;

		
	}

	//ensure we did not violate (i.e. we did not enter violation state)
	assert(me->_policy_p1_state != POLICY_STATE_runtime_lifecycle_enforcer_p1_violation);
}

//OUTPUT POLICY p1 END

//OUTPUT POLICY p2 BEGIN
//This will run the input enforcer for runtime_lifecycle_enforcer's policy p2
void runtime_lifecycle_enforcer_run_output_enforcer_p2(enforcervars_runtime_lifecycle_enforcer_t* me, inputs_runtime_lifecycle_enforcer_t* inputs, outputs_runtime_lifecycle_enforcer_t* outputs) {
	//advance timers
	
	
	//run enforcer
	switch(me->_policy_p2_state) {
		case POLICY_STATE_runtime_lifecycle_enforcer_p2_s0:
			
			if(inputs->W_E_G2 && me->D_G2_p2 == 0) {
				//transition s0 -> violation on ( W_E_G2 and D_G2_p2 = 0 )
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 

			break;

		case POLICY_STATE_runtime_lifecycle_enforcer_p2_s1:
			
			if(inputs->W_D_G2 == 1) {
				//transition s1 -> violation on ( W_D_G2 = 1 )
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 

			break;

		
	}

	//select transition to advance state
	switch(me->_policy_p2_state) {
		case POLICY_STATE_runtime_lifecycle_enforcer_p2_s0:
			
			if(inputs->W_E_G2 && me->D_G2_p2 == 1) {
				//transition s0 -> s1 on ( W_E_G2 and D_G2_p2 = 1 )
				me->_policy_p2_state = POLICY_STATE_runtime_lifecycle_enforcer_p2_s1;
				//set expressions
				
				me->E_G2_p2 = 1;
				break;
			} 
			if(inputs->W_D_G2) {
				//transition s0 -> s0 on ( W_D_G2 )
				me->_policy_p2_state = POLICY_STATE_runtime_lifecycle_enforcer_p2_s0;
				//set expressions
				
				me->D_G2_p2 = 1;
				break;
			} 
			if(inputs->W_E_G2 && me->D_G2_p2 == 0) {
				//transition s0 -> violation on ( W_E_G2 and D_G2_p2 = 0 )
				me->_policy_p2_state = POLICY_STATE_runtime_lifecycle_enforcer_p2_violation;
				//set expressions
				
				break;
			} 
			
			//ensure a transition was taken in this state
			assert(false && "runtime_lifecycle_enforcer_p2_s0 must take a transition"); //if we are still here, then no transition was taken and we are no longer satisfying liveness

			break;

		case POLICY_STATE_runtime_lifecycle_enforcer_p2_s1:
			
			if(inputs->W_E_G2) {
				//transition s1 -> s1 on ( W_E_G2 )
				me->_policy_p2_state = POLICY_STATE_runtime_lifecycle_enforcer_p2_s1;
				//set expressions
				
				break;
			} 
			if(inputs->W_D_G2 == 1) {
				//transition s1 -> violation on ( W_D_G2 = 1 )
				me->_policy_p2_state = POLICY_STATE_runtime_lifecycle_enforcer_p2_violation;
				//set expressions
				
				break;
			} 
			
			//ensure a transition was taken in this state
			assert(false && "runtime_lifecycle_enforcer_p2_s1 must take a transition"); //if we are still here, then no transition was taken and we are no longer satisfying liveness

			break;

		
	}

	//ensure we did not violate (i.e. we did not enter violation state)
	assert(me->_policy_p2_state != POLICY_STATE_runtime_lifecycle_enforcer_p2_violation);
}

//OUTPUT POLICY p2 END

//OUTPUT POLICY p3 BEGIN
//This will run the input enforcer for runtime_lifecycle_enforcer's policy p3
void runtime_lifecycle_enforcer_run_output_enforcer_p3(enforcervars_runtime_lifecycle_enforcer_t* me, inputs_runtime_lifecycle_enforcer_t* inputs, outputs_runtime_lifecycle_enforcer_t* outputs) {
	//advance timers
	
	
	//run enforcer
	switch(me->_policy_p3_state) {
		case POLICY_STATE_runtime_lifecycle_enforcer_p3_s0:
			
			if(inputs->W_B_G1 && me->D_G2_p3 == 0) {
				//transition s0 -> violation on ( W_B_G1 and ( D_G2_p3 = 0 ) )
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 

			break;

		case POLICY_STATE_runtime_lifecycle_enforcer_p3_s1:
			
			if(inputs->W_D_G2 == 1) {
				//transition s1 -> violation on ( W_D_G2 = 1 )
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 

			break;

		
	}

	//select transition to advance state
	switch(me->_policy_p3_state) {
		case POLICY_STATE_runtime_lifecycle_enforcer_p3_s0:
			
			if(inputs->W_B_G1 && me->D_G2_p3 == 1) {
				//transition s0 -> s1 on ( W_B_G1 and D_G2_p3 = 1 )
				me->_policy_p3_state = POLICY_STATE_runtime_lifecycle_enforcer_p3_s1;
				//set expressions
				
				me->B_G1_p3 = 1;
				break;
			} 
			if(inputs->W_D_G2) {
				//transition s0 -> s0 on ( W_D_G2 )
				me->_policy_p3_state = POLICY_STATE_runtime_lifecycle_enforcer_p3_s0;
				//set expressions
				
				me->D_G2_p3 = 1;
				break;
			} 
			if(inputs->W_B_G1 && me->D_G2_p3 == 0) {
				//transition s0 -> violation on ( W_B_G1 and ( D_G2_p3 = 0 ) )
				me->_policy_p3_state = POLICY_STATE_runtime_lifecycle_enforcer_p3_violation;
				//set expressions
				
				break;
			} 
			
			//ensure a transition was taken in this state
			assert(false && "runtime_lifecycle_enforcer_p3_s0 must take a transition"); //if we are still here, then no transition was taken and we are no longer satisfying liveness

			break;

		case POLICY_STATE_runtime_lifecycle_enforcer_p3_s1:
			
			if(inputs->W_B_G1) {
				//transition s1 -> s1 on ( W_B_G1 )
				me->_policy_p3_state = POLICY_STATE_runtime_lifecycle_enforcer_p3_s1;
				//set expressions
				
				break;
			} 
			if(inputs->W_D_G2 == 1) {
				//transition s1 -> violation on ( W_D_G2 = 1 )
				me->_policy_p3_state = POLICY_STATE_runtime_lifecycle_enforcer_p3_violation;
				//set expressions
				
				break;
			} 
			
			//ensure a transition was taken in this state
			assert(false && "runtime_lifecycle_enforcer_p3_s1 must take a transition"); //if we are still here, then no transition was taken and we are no longer satisfying liveness

			break;

		
	}

	//ensure we did not violate (i.e. we did not enter violation state)
	assert(me->_policy_p3_state != POLICY_STATE_runtime_lifecycle_enforcer_p3_violation);
}

//OUTPUT POLICY p3 END



//This function is provided in "F_runtime_lifecycle_enforcer.c"
//It will check the state of the enforcer monitor code
//It returns one of the following:
//0: currently true (safe)
//1: always true (safe)
//-1: currently false (unsafe)
//-2: always false (unsafe)
//It will need to do some reachability analysis to achieve this

